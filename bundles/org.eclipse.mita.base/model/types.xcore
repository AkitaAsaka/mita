@GenModel(copyrightText="generated by Xtext 2.13.0", operationReflection="false", modelDirectory="/org.eclipse.mita.base/emf-gen")
package org.eclipse.mita.base.types

import java.util.HashSet
import java.util.Set
import org.eclipse.emf.common.util.BasicEList

class TypeSpecifier {}
class PresentTypeSpecifier extends TypeSpecifier {
	refers Type ^type
	contains PresentTypeSpecifier[] typeArguments
	
	transient boolean optional
	transient String[] referenceModifiers
	
	op String toString() {
		val args = if(typeArguments.empty) {
			""
		} else {
			"<" + typeArguments.map[if(it === null) {"null"} else {it.toString}].reduce[p1, p2| p1 + ", " + p2] + ">"
		}
		
//		val nameNode = NodeModelUtils.findNodesForFeature(this, TypesPackage.Literals.TYPE_SPECIFIER__TYPE).head;
//		val typeName = if(nameNode === null) {
//			"null";
//		} else {
//			NodeModelUtils.getTokenText(nameNode);
//		};
		val typeName = if(^type === null) {
			"null"
		} else {
			^type.toString
		}
		return typeName + args;
	}
}

class NullTypeSpecifier extends TypeSpecifier {
	op String toString() {
		return "";
	}
}

abstract class NamedElement {
	String name
}
abstract class PackageMember extends NamedElement {
	derived id String ^id get {
		return TypesUtil.computeQID(this);
	}
}
class Package extends PackageMember {
	contains PackageMember[] member
	refers Package[] ^import
}
abstract class Type extends PackageMember {
	boolean ^abstract
	op Type getOriginType() {
		return this;
	}
	
	refers Type[] superTypes
	contains TypeConstraint[] constraint
	
	op String toString() {
		return name;
	}
}
class TypeConstraint {
	Object value
}
class PrimitiveType extends Type, Exportable {
	op String toString() {
		return super.toString();
	}
}
class ComplexType extends Type, GenericElement {
	contains Declaration[] features
	
	op Declaration[] getAllFeatures() {
		val features = new BasicEList<Declaration>();
		collectFeatures(this, features, new HashSet<Type>());
		return features;
	}
	
	op void collectFeatures(Type tpe, Declaration[] features, Object _visited) {
		val visited = _visited as Set<Type>;
		if (tpe === null || visited.contains(tpe))
			return;
		if (tpe instanceof ComplexType) {
			for (Type superType : tpe.getSuperTypes()) {
				collectFeatures(superType, features, visited);
			}
			features.addAll(tpe.getFeatures());
		}
		visited.add(tpe);
	}
	
}
class GenericElement extends NamedElement {
	contains TypeParameter[] typeParameters
}
class TypeParameter extends Type {
	refers Type bound
}
class Declaration extends TypedElement, NamedElement, PackageMember {
	
}
abstract class TypedElement {
	contains TypeSpecifier typeSpecifier
	
	op Type getType() {
		if (getTypeSpecifier() instanceof PresentTypeSpecifier) {
			return (getTypeSpecifier() as PresentTypeSpecifier).getType();
		}
		return null;
	}
}

class ParameterList {
	container Operation owningOperation opposite parameters
	contains Parameter[] parameters opposite parameterList
	op String toString() {
		return parameters.join(", ")
	}
}

class Operation extends Declaration, GenericElement {
	contains ParameterList parameters opposite owningOperation
	
	op String toString() {
		val typeParameterString = if(typeParameters.empty) {
			""
		} 
		else {
			"<" + typeParameters.join(", ") + ">"
		}
		val parameterString = parameters.toString
		return name + typeParameterString + "(" + parameterString + ")"
	}
}
class Parameter extends TypedElement, NamedElement {
	container ParameterList parameterList opposite parameters
	boolean optional
	
	op String toString() {
		val optionalModifier = if(optional) {
			"?"
		}
		else {
			""
		}
		return name + ": " + typeSpecifier
	}
}
class Enumerator extends Declaration {
	container EnumerationType owningEnumeration opposite enumerator
}
class EnumerationType extends PrimitiveType {
	contains Enumerator[] enumerator opposite owningEnumeration
	op String toString() {
		return super.toString()
	}
}

abstract class GeneratedElement {
	/**
	 * The fully-qualified class name of the generator class. 
	 */
	String generator
	
	/**
	 * The optional fully-qualified name of the validator class.
	 */
	String validator
	
	/**
	 * The optional fully-qualified name of the element size inferrer class.
	 */
	String sizeInferrer
}


interface HasAccessors {
	/**
	 * caution: this is only the type from the parsed model, not neccessarily the inferred type. Use with caution for type inferrence.
	 */
	op PresentTypeSpecifier[] accessorsTypes()
}

class Exportable {
	boolean exported
}

class ExceptionTypeDeclaration extends Type, Exportable {
}

class NativeType extends PrimitiveType, Exportable {
	String aliasOf
	String header
	
	op String getCName() {
		if(aliasOf === null) {
			return name
		} else {
			return aliasOf
		}
	}
	
	op String toString() {
		return name
	}
}

class StructureType extends ComplexType, HasAccessors, Exportable {
	contains Parameter[] parameters
	op PresentTypeSpecifier[] accessorsTypes() {
		return parameters.map[it.typeSpecifier].filter(PresentTypeSpecifier).toEList;
	}
	
	op String toString() {
		super.toString
	}
}

class GeneratedType extends ComplexType, GeneratedElement, Exportable {
	contains Operation constructor
	
	op String toString() {
		super.toString
	}
}

class PackageAssociation {
	String name
}

class ImportStatement {
	String importedNamespace
}
 

class SumType extends ComplexType, Exportable {
	// I would use features, but if I want to have SumAlternative as a ComplexType (which it is), then I can't make it a Declaration as well
	contains SumAlternative[] alternatives opposite sumType
	
	op String toString() {
		return super.toString();
	}
}
interface SumAlternative extends ComplexType, HasAccessors {
	container SumType sumType opposite alternatives
	
	op Type realType() {
		return this;
	}
	
	op Type[] getSuperTypes() {
		if (!super.superTypes.contains(sumType)) {
			super.superTypes.add(sumType);
		}
		return super.superTypes
	}
}
class Singleton extends SumAlternative {
	op PresentTypeSpecifier[] accessorsTypes() {
		return #[].asEList;
	}
}
class AnonymousProductType extends SumAlternative {
	contains PresentTypeSpecifier[] typeSpecifiers 
	op Type realType() {
		if(typeSpecifiers.length == 1) {
			val actualType = typeSpecifiers.get(0);
			return actualType.^type;
		}
		return this;	
	}
	op PresentTypeSpecifier[] accessorsTypes() {
		// need to duplicate functionality, since calling realType and deferring to that ones accessor types would create infinite recursion if it returns this
		// could check with == this, but that would be more confusing I think
		if(typeSpecifiers.length == 1) {
			val actualTypeSpec = typeSpecifiers.get(0)
				val actualType = actualTypeSpec.^type;
				if(actualType instanceof HasAccessors) {
					return actualType.accessorsTypes;
				}				
		}
		return typeSpecifiers;
	}
}
class NamedProductType extends SumAlternative, HasAccessors {
	contains Parameter[] parameters
	// always return parameter types, since we never embed
	op PresentTypeSpecifier[] accessorsTypes() {
		return parameters.map[it.typeSpecifier].filter(PresentTypeSpecifier).toEList;
	}
}
class ProductMember extends Parameter { }

class TypeAlias extends Type, Declaration {
	
	op Type getOriginType() {
		val baseType = getType();
		if (baseType instanceof TypeAlias && baseType != this) {
			return baseType.getOriginType();			
		}
		return baseType;
	}
	
}

class Property extends Declaration {
	boolean const
	boolean external
	boolean ^readonly
}

class Event extends Declaration {
	
}
